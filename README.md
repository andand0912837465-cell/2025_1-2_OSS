# 2025_1-2_OSS
1학년 2학기 오픈소프트웨어과목 저장소

##  Week 1
##  Week 2 
버전 관리와 Git/GitHub 개요 (Files 1-3)

2주차는 \*\*버전 관리(Version Control)\*\*의 필요성과 개념, 그리고 대표적인 도구인 **Git**과 **GitHub**의 기초 개념을 학습합니다.

### 1\. 오픈소스 소프트웨어(OSS)와 버전 관리의 개념

  * **오픈소스 소프트웨어 (OSS, Open Source Software)**: 소스 코드가 공개되어 누구나 자유롭게 확인, 수정, 개작, 재배포할 수 있는 소프트웨어입니다. 일반 대중의 공동 연구로 개발 및 개선되며, 소스 코드가 공유되어야 한다는 사상을 기반으로 합니다.
  * **버전 관리의 필요성**: 프로젝트를 진행하면서 파일 내용이 변경될 때마다 이름을 바꿔 복사하거나 폴더를 새로 만들어 관리하면 비효율적입니다. 버전 관리는 지난 어느 시점의 파일이나 소스 내용을 쉽게 확인하고, 필요하면 그 상태로 **되돌릴 수 있도록(Time Travel)** 돕기 위해 필요합니다.

### 2\. Git과 GitHub의 기초

  * **Git (깃)**: 2005년 리누스 토발즈(Linus Torvalds)가 개발한 \*\*분산형 버전 관리 시스템(DVCS)\*\*입니다. 파일의 변경 이력을 효율적으로 관리합니다.
  * **GitHub (깃허브)**: 분산 환경 소스코드 버전 관리 도구인 Git의 **글로벌 웹 호스팅 서비스**입니다. 5천만 명 이상의 개발자가 함께 소프트웨어를 만드는 세계 최대의 오픈소스 공유 플랫폼입니다.
      * **원격 저장소 (Remote Repository)**: GitHub와 같이 네트워크상의 서버에 위치한 저장소입니다. 여러 사람이 공유하는 중앙 저장소의 역할을 합니다.
      * **지역 저장소 (Local Repository)**: 개발자의 PC에 위치하며, 평소에 실제 작업을 하는 저장소입니다.

### 3\. Git의 3가지 핵심 영역

Git은 파일을 관리하기 위해 3가지 영역을 사용합니다. 파일은 이 영역들을 거치면서 버전 이력으로 기록됩니다.

| 영역 (Area) | 설명 | 파일 상태 (예시) |
| :--- | :--- | :--- |
| **작업 디렉토리 (Working Directory)** | 실제 파일을 추가/수정하는 개발 공간입니다. | `modified` (수정됨), `untracked` (추적되지 않음) |
| **스테이징 영역 (Staging Area/Index)** | 다음 커밋에 포함할 파일을 선별하여 준비하는 임시 공간입니다. `git add` 명령으로 이동합니다. | `staged` (준비됨), `indexed` |
| **깃 저장소 (Git Repository, `.git`)** | 최종적으로 버전 이력(Commit)이 영구 저장되는 곳입니다. `git commit` 명령으로 저장됩니다. | `Committed` |

-----

##  Week 3
Git 환경 설정 및 기본 명령어 (Files 4-6)

3주차는 Git을 설치하고, Git의 사용 환경을 설정하며, Git 실습을 위해 필요한 \*\*Visual Studio Code(VS Code)\*\*와 **리눅스 기초 명령어**를 익힙니다.

### 1\. Git 설치 및 실행

  * **Git 다운로드**: Git 공식 홈페이지 `https://git-scm.com/` 에서 설치 파일을 다운로드합니다.
  * **Git 설치 시 제공 소프트웨어**:
      * **Git Bash**: Git 명령을 실행하기 위한 **CLI(Command Line Interface)** 환경을 제공합니다 (리눅스 명령어 기반).
      * **Git GUI**: Git 명령을 그래픽 환경(GUI)에서 실행할 수 있도록 합니다.
  * **Git 실행**: 탐색기에서 원하는 폴더를 선택하고 마우스 우클릭 후 \*\*'Git Bash Here'\*\*를 선택하여 해당 폴더에서 바로 Git Bash를 실행할 수 있습니다.

### 2\. Git 환경 설정 및 저장소 생성

Git을 사용하기 전, 누가 이력을 남겼는지 식별하고 기본 설정을 지정하기 위해 **글로벌 설정**을 먼저 수행해야 합니다깃 설정과 저장소 생성.pdf].

| 명령 (Command) | 설명 |
| :--- | :--- |
| `git config --global user.name "사용자 이름"` | 커밋 이력에 남길 **사용자 이름**을 설정합니다깃 설정과 저장소 생성.pdf]. |
| `git config --global user.email "전자메일 주소"` | 커밋 이력에 남길 **전자메일 주소**를 설정합니다깃 설정과 저장소 생성.pdf]. |
| `git config --global core.editor 'code --wait'` | 기본 편집기를 **VS Code**로 설정합니다 (VS Code가 설치되어 있어야 함)깃 설정과 저장소 생성.pdf]. |
| `git config --global init.defaultBranch main` | 새로 생성되는 저장소의 **기본 브랜치 이름**을 `main`으로 설정합니다깃 설정과 저장소 생성.pdf]. |

  * **지역 저장소 생성**: 버전 관리를 시작할 폴더를 지정하고 그 안에 Git을 초기화합니다.
    ```bash
    $ git init [저장소_폴더명]  # 지정된 폴더에 깃 저장소(.git 폴더)를 생성
    $ cd [저장소_폴더명]      # 해당 폴더로 이동
    ```

### 3\. VS Code 및 리눅스 기초 명령

Git Bash 환경은 리눅스 명령어를 사용하므로, 파일 및 폴더 관리를 위한 기초 리눅스 명령을 알아야 합니다.

| 명령 (Command) | 설명 | 활용 예시 |
| :--- | :--- | :--- |
| `pwd` (print working directory) | 현재 작업 중인 디렉토리(폴더)의 경로를 출력합니다. | |
| `ls -al` (list) | 현재 폴더의 파일/폴더 목록을 숨김 파일(`-a`) 포함하여 자세한 정보와(`-l`) 함께 출력합니다. | |
| `cat [파일]` (concatenate) | 파일의 내용을 화면에 출력합니다. | |
| `echo "문자열"` | 문자열을 화면에 출력합니다. 파일 생성 및 수정에 주로 사용됩니다. | |
| `touch [파일]` | 비어있는 새 파일을 생성합니다. | |
| **`>` (리다이렉션)** | 화면의 출력 결과를 파일로 저장하며, **기존 내용을 지우고** 덮어씁니다. | `$ echo "1st line" > file.txt` |
| **`>>` (리다이렉션)** | 화면의 출력 결과를 파일로 저장하며, **기존 내용 뒤에 덧붙여서** 저장합니다. | `$ echo "2nd line" >> file.txt` |

-----

##  Week 4
커밋, 로그 이력, 과거 버전 이동 (Files 7-9)

4주차는 Git의 핵심인 **버전 이력 저장(Commit)** 과정과 저장된 이력을 확인하고, 이전 버전으로 돌아가는 **시간 여행(Time Travel)** 기술을 실습합니다.

### 1\. 버전 이력 저장 (Add & Commit)

Git에서 버전 이력을 기록하려면 반드시 **`add` 명령 후 `commit` 명령**을 순서대로 실행해야 합니다.

| 명령 (Command) | 기능 |
| :--- | :--- |
| **`$ git status`** | 현재 파일들이 3가지 영역(작업 디렉토리, 스테이징 영역, 깃 저장소) 중 어디에 있는지, 파일의 상태(수정됨, 추적되지 않음 등)를 표시합니다. (`-s` 옵션으로 간결하게 볼 수 있습니다). |
| **`$ git add [파일/폴더]`** | 작업 디렉토리에서 수정한 파일이나 새로 생성된 파일(`untracked` or `modified`)을 **스테이징 영역**으로 이동시켜 커밋할 준비를 합니다. |
| **`$ git commit -m '메시지'`** | 스테이징 영역에 준비된 파일들을 **깃 저장소**에 최종 저장하며, 하나의 \*\*버전(커밋)\*\*으로 기록합니다. 이때 커밋 메시지(`-m '메시지'`)를 반드시 입력해야 합니다. |
| **`$ git commit -am '메시지'`** | `add`와 `commit`을 한 번에 실행합니다. 다만, **이미 Git이 추적하는 파일**을 수정한 경우에만 사용 가능합니다. |

### 2\. 버전 이력 확인 (Log & Show)

커밋된 버전 이력을 확인하는 명령입니다.

| 명령 (Command) | 기능 |
| :--- | :--- |
| **`$ git log`** | 저장된 모든 커밋 이력을 시간 순으로 상세하게 표시합니다. |
| **`$ git log --oneline`** | 커밋 이력을 각 커밋당 **한 줄**로 간결하게 표시합니다. 짧은 커밋 ID와 메시지를 볼 수 있습니다. |
| **`$ git log --graph`** | 커밋 이력을 **그래프** 형태로 표시하여 브랜치 및 병합 이력을 시각적으로 보여줍니다 커밋과 로그 이력, 과거 여행.pdf]. |
| **`$ git show`** | 가장 최근의 커밋(`HEAD`)에 대한 상세 정보와 함께 이전 버전과의 파일 \*\*변경 차이(Diff)\*\*를 표시합니다. |

> 💡 **커밋 ID (Commit ID)**: 모든 커밋을 구분하기 위한 고유한 번호입니다. SHA-1 해시 함수를 사용하여 생성된 40자리의 16진수 체크섬(checksum)입니다.

### 3\. 과거 버전으로의 이동 (Time Travel)

Git은 **HEAD**라는 포인터를 사용하여 현재 작업 중인(최신) 커밋을 가리킵니다. 이 **HEAD**를 이동하여 과거 버전으로 돌아갈 수 있습니다.

| 표현 (Expression) | 의미 |
| :--- | :--- |
| **`HEAD`** | 현재 작업하고 있는 **최신 커밋**을 가리킵니다. |
| **`HEAD~`** | 바로 **직전 커밋**을 가리킵니다 (HEAD의 1단계 이전). |
| **`HEAD~2` 또는 `HEAD~~`** | 현재로부터 **2단계 이전 커밋**을 가리킵니다. |

  * **과거 버전으로 이동**:

    ```bash
    $ git checkout HEAD~  # 바로 이전 커밋으로 HEAD를 이동 (과거 버전으로 이동)
    # 또는
    $ git checkout [커밋ID] # 특정 커밋 ID의 버전으로 이동
    ```

     `git checkout`은 브랜치 전환에도 사용되므로, 최근에는 \*\*`git switch -d [커밋ID]`\*\*를 사용하여 과거 버전으로 이동하는 것이 권장됩니다 커밋과 로그 이력, 과거 여행.pdf].

  * **최신 버전(브랜치)으로 복귀**:
    과거 버전으로 이동한 후 다시 최신 작업 내용이 있는 상태로 돌아가려면 **브랜치 이름**을 사용하여 복귀합니다.

    ```bash
    $ git checkout main  # 최신 버전(main 브랜치)으로 HEAD를 이동하여 복귀
    ```
##  Week 6 
파일 비교, 삭제, 복원 명령어 (Files 10-12)

### 1\. 파일 비교 (`git diff`)

`git diff` 명령은 Git의 3가지 영역 간의 파일 변경 내용을 보여주는 데 사용됩니다.

| 비교 대상 | 명령 (Command) | 설명 |
| :--- | :--- | :--- |
| **작업 디렉토리 ↔ 스테이징 영역** | **`$ git diff`** | 파일을 수정한 후 **`git add`를 하지 않은** 변경 내용, 즉 다음 커밋에 포함되지 않을 내용. |
| **스테이징 영역 ↔ 깃 저장소 (HEAD)** | **`$ git diff --staged`** (또는 `--cached`) | `git add`는 했지만 **`git commit`을 하지 않은** 변경 내용. |
| **깃 저장소 (HEAD) ↔ 작업 디렉토리** | **`$ git diff HEAD`** | 최신 커밋 이후 발생한 **모든** 변경 내용(add 여부 관계없이). |
| **특정 커밋 ↔ 다른 커밋** | **`$ git diff [커밋ID1] [커밋ID2]`** | 두 특정 버전(커밋) 간의 파일 변경 내용을 비교. |

### 2\. 파일 삭제 (`rm`, `git rm`)

파일을 삭제하는 방법은 Git의 추적(버전 관리) 여부에 따라 다릅니다.

| 명령 (Command) | 기능 | 설명 |
| :--- | :--- | :--- |
| **`$ rm [파일]`** (리눅스) | **작업 디렉토리**에서만 삭제 | Git 입장에서는 파일이 '수정됨(deleted)' 상태로 인식되며, `git add` 후 `commit` 해야 최종 삭제 이력이 남습니다. |
| **`$ git rm [파일]`** (Git) | **작업 디렉토리**와 **스테이징 영역**에서 삭제 | 파일을 삭제하고 동시에 다음 커밋에 반영할 준비(`staged`)를 합니다. |
| **`$ git rm --cached [파일]`** | **스테이징 영역**에서만 삭제 | 파일은 작업 디렉토리에 남겨두고, Git의 버전 관리 대상에서는 제외합니다 (`untracked` 상태). |

### 3\. 파일 복원 (`git restore`)

삭제되거나 변경된 파일을 이전 상태로 되돌립니다. **`git restore`** 명령은 작업 디렉토리 또는 스테이징 영역의 상태를 복구할 때 사용합니다.

| 명령 (Command) | 복원 대상 | 복원 기준 |
| :--- | :--- | :--- |
| **`$ git restore [파일]`** | **작업 디렉토리** | **스테이징 영역**에 있는 내용. |
| **`$ git restore --staged [파일]`** | **스테이징 영역** | \*\*깃 저장소(HEAD)\*\*의 내용. |
| **`$ git restore --source=HEAD --staged --worktree [파일]`** | **작업 디렉토리**와 **스테이징 영역** 모두 | \*\*깃 저장소(HEAD)\*\*의 내용 (가장 최신 커밋 상태로 완전히 복구) 파일 diff rm restore.pdf]. |

-----

##  Week 7
버전 태그 및 브랜치 관리 (Files 13-15)

6주차는 소프트웨어의 중요한 버전을 표시하는 **태그** 기능과, 여러 개발 흐름을 분리하여 관리하는 **브랜치**의 개념 및 사용법을 익힙니다.

### 1\. 버전과 태그 활용 (`git tag`)

  * **버전 (Version)**: 프로그램의 수정 및 개선 정도를 구분하기 위해 부여하는 식별자입니다. 일반적으로 **Semantic Versioning (SemVer)** 방식(예: `Major.Minor.Patch`)을 따릅니다.
  * **태그 (Tag)**: Git에서 특정 커밋(**버전**)에 의미있는 이름을 부여하여 중요한 릴리즈 지점(예: v1.0.0)을 표시할 때 사용합니다.

| 명령 (Command) | 종류 | 설명 |
| :--- | :--- | :--- |
| **`$ git tag v1.0`** | 일반 태그 | 특정 커밋에 간단한 별칭 부여. |
| **`$ git tag -a v1.0 -m '메시지'`** | **주석 태그** (권장) | 태그를 만든 사람, 이메일, 생성일, 주석 메시지 등의 상세 정보를 포함. |
| **`$ git tag`** | 태그 목록 보기 | 현재 저장소에 있는 모든 태그 목록을 출력. |
| **`$ git show [태그이름]`** | 태그 상세 보기 | 특정 태그에 대한 상세 정보(특히 주석 태그의 메시지)를 출력. |
| **`$ git tag -d [태그이름]`** | 태그 삭제 | 지정된 태그를 삭제. |

### 2\. 브랜치 개요와 관리 (`git branch`, `git switch`)

  * **브랜치 (Branch) 개념**: 파일 집합을 통째로 복사하여 독립적으로 개발을 진행하는 개념입니다. 하나의 프로젝트에서 메인 코드에 영향을 주지 않고 새로운 기능 개발, 버그 수정 등을 동시에 진행할 수 있습니다.

| 명령 (Command) | 기능 | 설명 |
| :--- | :--- | :--- |
| **`$ git branch`** | 브랜치 목록 확인 | 지역 저장소의 브랜치 목록을 확인하고, 현재 작업 중인 브랜치(`HEAD`)를 `*`로 표시. |
| **`$ git branch [이름]`** | 브랜치 생성 | 현재 커밋 상태를 기준으로 새로운 브랜치를 생성. |
| **`$ git switch [이름]`** | 브랜치 이동 (전환) | **HEAD** 포인터를 지정된 브랜치로 이동 (최신 권장 명령). |
| **`$ git switch -c [이름]`** | 생성 및 이동 | 브랜치를 **생성**과 동시에 해당 브랜치로 **이동**. |
| **`$ git branch -d [이름]`** | 브랜치 삭제 | **병합된** 브랜치를 안전하게 삭제. |
| **`$ git branch -D [이름]`** | 브랜치 강제 삭제 | **병합되지 않은** 내용이 있어도 강제로 삭제 (주의 필요). |

-----

## Week 8  
원격 저장소 연동 (Files 16-18)

7주차는 지역 저장소(내 PC)와 GitHub 같은 **원격 저장소**를 연결하여 협업의 기초가 되는 `clone`, `push`, `pull` 명령어를 실습합니다.

### 1\. 원격 저장소 복제 (`git clone`)

  * **원격 저장소**: GitHub처럼 네트워크상의 서버에 위치하며, 여러 개발자가 공유하는 저장소입니다.
  * **Clone (복제)**: 원격 저장소의 전체 내용을 내 PC의 **지역 저장소**로 통째로 복사해 가져오는 명령입니다 지역과 원격 저장소 브랜치 연동.pdf]. 공개된 저장소는 소유와 관계없이 누구나 복제 가능합니다.
    ```bash
    $ git clone [원격_저장소_URL]
    ```
      * 복제 시, Git은 자동으로 원격 저장소에 \*\*`origin`\*\*이라는 기본 별칭(별명)을 부여합니다.

### 2\. 지역과 원격 저장소 동기화 (Push, Pull, Fetch)

지역 저장소에서 작업한 내용을 원격에 반영하거나, 원격의 최신 변경 사항을 지역으로 가져올 때 사용되는 핵심 명령어입니다.

| 명령어 | 방향 | 기능 | 설명 |
| :--- | :--- | :--- | :--- |
| **`$ git push`** | 지역 → 원격 (업로드) | 지역 저장소의 커밋을 원격 저장소(`origin`)로 올려 **공개**합니다 지역과 원격 저장소 브랜치 연동.pdf]. |
| **`$ git pull`** | 원격 → 지역 (가져오기 + 병합) | 원격의 최신 내용을 가져와(`fetch`) **자동으로** 현재 지역 브랜치에 \*\*병합(`merge`)\*\*까지 수행합니다. |
| **`$ git fetch`** | 원격 → 지역 (가져오기만) | 원격의 최신 내용을 가져와 지역에 저장하지만, **병합은 하지 않습니다**. 가져온 내용을 확인한 후 수동으로 `git merge`를 수행할 때 사용합니다. |

### 3\. 개인 접근 토큰 (Personal Access Token, PAT)

  * **필요성**: GitHub는 2021년 8월 13일 이후부터 보안상의 이유로 기존의 **비밀번호 인증을 더 이상 지원하지 않습니다**.
  * **역할**: 대신 \*\*개인 접근 토큰(PAT)\*\*을 생성하여 Push/Pull 등의 원격 저장소 접근 시 인증 수단으로 사용해야 합니다.
  * **인증 방법**: `git push` 실행 시 브라우저를 통한 인증 화면이 나타나거나, 생성한 PAT를 직접 입력하여 인증을 수행합니다 지역과 원격 저장소 브랜치 연동.pdf].

##  Week 10
## 1. OSS의 정의 및 의미
- **OSS(Open Source Software)**  
  누구나 소스 코드를 자유롭게 보고, 사용, 수정, 배포할 수 있는 소프트웨어
- 핵심: 단순한 무료가 아니라 **자유(Freedom) 보장**
- **OSI(Open Source Initiative)**  
  공개 소스 정의(OSD) 관리 및 인증 마크 부여
- **자유 소프트웨어 vs 오픈소스**
  - 자유 소프트웨어: 사용자의 자유, 철학 강조
  - 오픈소스: 실용성, 기술적 활용 강조

## 2. OSS 주요 라이선스
- **GPL**
  - Copyleft 강함
  - 소스 공개 의무 O
  - 파생물도 반드시 GPL 유지
- **LGPL**
  - Copyleft 중간
  - 동적 링크 시 애플리케이션 공개 X
- **Apache 2.0**
  - Permissive 약함
  - 소스 공개 의무 X
  - 특허 사용 허용
- **MIT**
  - Permissive 매우 약함
  - 저작권 명시만 하면 자유로움

## 3. Stash (임시 저장)
- 커밋하지 않은 변경 사항을 스택에 저장
- 브랜치 전환 시 임시 보관에 사용

## 4. Untracked 파일 삭제
```bash
git clean -n   # 삭제될 목록 확인
git clean -f   # 실제 삭제
git clean -i   # 대화형 선택 삭제
````

---

# Week 11 — Merge

## 1. Fast-forward Merge

* 이력이 일직선일 때
* 병합 커밋 없이 포인터만 이동

## 2. 3-way Merge

* 이력이 갈라진 상황
* 공통 조상 기준으로 병합 커밋 생성

```bash
git merge --no-ff [branch]  # 강제로 병합 커밋 생성
```

## 3. Squash Merge

* 여러 커밋을 하나로 압축

```bash
git merge --squash [branch]
git commit
```

## 4. 병합 충돌

* 동일 라인을 다르게 수정한 경우
* 메시지: `CONFLICT (content)`

## 5. 충돌 해결

* 마커 제거 후 스테이징

```bash
git add [file]
git commit
git merge --abort   # 충돌 해결 취소 시
```

---

# Week 12 — Rebase

## 1. Rebase 개요

* 커밋 기준점을 다른 커밋 위로 이동
* 히스토리를 **직선(Linear)** 으로 유지

## 2. 주의사항

* **공유된 커밋에는 절대 사용 금지**

## 3. 최신 커밋 수정

```bash
git add [file]
git commit --amend
```

## 4. 과거 커밋 수정 (Interactive Rebase)

```bash
git rebase -i HEAD~N
```

* pick: 그대로
* reword : 메시지 수정
* squash: 이전 커밋과 통합
* drop: 삭제

## 5. VS Code 기능

* Source Control 메뉴
* Git Graph 확장
* Diff 비교
* Restore로 변경 취소

---

# Week 13 — 버전 되돌리기

## 1. Reset 개요

* 브랜치 포인터 이동 → **이력 삭제 위험**
* Repository / Index / Working Directory 각각에 영향 다름

```bash
git reset --hard ORIG_HEAD  # 실수 복구 가능
```

## 2. Revert 개요

* 원격 공유 커밋 되돌릴 때 안전
* 새로운 취소 커밋 추가

```bash
git revert [commitID]
git revert --no-edit
git revert --continue
git revert --abort
```

```

---

이제 Git에서 줄바꿈도 완벽하게 보입니다.  
원하면 제목 색상, 그림, 커밋 그래프 시각화도 추가해 드릴 수 있어요.  
또 GitHub README 스타일로 아이콘 달아서 더 예쁘게 꾸밀 수도 있고요.
```




