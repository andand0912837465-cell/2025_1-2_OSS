# 2025_1-2_OSS
1학년 2학기 오픈소프트웨어과목 저장소

##  Week 1
##  Week 2 
버전 관리와 Git/GitHub 개요 

### 1\. 오픈소스 소프트웨어(OSS)와 버전 관리의 개념

  * **오픈소스 소프트웨어 (OSS, Open Source Software)**: 소스 코드가 공개되어 누구나 자유롭게 확인, 수정, 개작, 재배포할 수 있는 소프트웨어입니다. 일반 대중의 공동 연구로 개발 및 개선되며, 소스 코드가 공유되어야 한다는 사상을 기반으로 합니다.
  * **버전 관리의 필요성**: 프로젝트를 진행하면서 파일 내용이 변경될 때마다 이름을 바꿔 복사하거나 폴더를 새로 만들어 관리하면 비효율적입니다. 버전 관리는 지난 어느 시점의 파일이나 소스 내용을 쉽게 확인하고, 필요하면 그 상태로 **되돌릴 수 있도록(Time Travel)** 돕기 위해 필요합니다.

### 2\. Git과 GitHub의 기초

  * **Git (깃)**: 2005년 리누스 토발즈(Linus Torvalds)가 개발한 \*\*분산형 버전 관리 시스템(DVCS)\*\*입니다. 파일의 변경 이력을 효율적으로 관리합니다.
  * **GitHub (깃허브)**: 분산 환경 소스코드 버전 관리 도구인 Git의 **글로벌 웹 호스팅 서비스**입니다. 5천만 명 이상의 개발자가 함께 소프트웨어를 만드는 세계 최대의 오픈소스 공유 플랫폼입니다.
      * **원격 저장소 (Remote Repository)**: GitHub와 같이 네트워크상의 서버에 위치한 저장소입니다. 여러 사람이 공유하는 중앙 저장소의 역할을 합니다.
      * **지역 저장소 (Local Repository)**: 개발자의 PC에 위치하며, 평소에 실제 작업을 하는 저장소입니다.

### 3\. Git의 3가지 핵심 영역

Git은 파일을 관리하기 위해 3가지 영역을 사용합니다. 파일은 이 영역들을 거치면서 버전 이력으로 기록됩니다.

| 영역 (Area) | 설명 | 파일 상태 (예시) |
| :--- | :--- | :--- |
| **작업 디렉토리 (Working Directory)** | 실제 파일을 추가/수정하는 개발 공간입니다. | `modified` (수정됨), `untracked` (추적되지 않음) |
| **스테이징 영역 (Staging Area/Index)** | 다음 커밋에 포함할 파일을 선별하여 준비하는 임시 공간입니다. `git add` 명령으로 이동합니다. | `staged` (준비됨), `indexed` |
| **깃 저장소 (Git Repository, `.git`)** | 최종적으로 버전 이력(Commit)이 영구 저장되는 곳입니다. `git commit` 명령으로 저장됩니다. | `Committed` |

-----

##  Week 3
Git 환경 설정 및 기본 명령어 

### 1\. Git 설치 및 실행

  * **Git 다운로드**: Git 공식 홈페이지 `https://git-scm.com/` 에서 설치 파일을 다운로드합니다.
  * **Git 설치 시 제공 소프트웨어**:
      * **Git Bash**: Git 명령을 실행하기 위한 **CLI(Command Line Interface)** 환경을 제공합니다 (리눅스 명령어 기반).
      * **Git GUI**: Git 명령을 그래픽 환경(GUI)에서 실행할 수 있도록 합니다.
  * **Git 실행**: 탐색기에서 원하는 폴더를 선택하고 마우스 우클릭 후 \*\*'Git Bash Here'\*\*를 선택하여 해당 폴더에서 바로 Git Bash를 실행할 수 있습니다.

### 2\. Git 환경 설정 및 저장소 생성

Git을 사용하기 전, 누가 이력을 남겼는지 식별하고 기본 설정을 지정하기 위해 **글로벌 설정**을 먼저 수행해야 합니다깃 설정과 저장소 생성.pdf].

| 명령 (Command) | 설명 |
| :--- | :--- |
| `git config --global user.name "사용자 이름"` | 커밋 이력에 남길 **사용자 이름**을 설정합니다깃 설정과 저장소 생성.pdf]. |
| `git config --global user.email "전자메일 주소"` | 커밋 이력에 남길 **전자메일 주소**를 설정합니다깃 설정과 저장소 생성.pdf]. |
| `git config --global core.editor 'code --wait'` | 기본 편집기를 **VS Code**로 설정합니다 (VS Code가 설치되어 있어야 함)깃 설정과 저장소 생성.pdf]. |
| `git config --global init.defaultBranch main` | 새로 생성되는 저장소의 **기본 브랜치 이름**을 `main`으로 설정합니다깃 설정과 저장소 생성.pdf]. |

  * **지역 저장소 생성**: 버전 관리를 시작할 폴더를 지정하고 그 안에 Git을 초기화합니다.
    ```bash
    $ git init [저장소_폴더명]  # 지정된 폴더에 깃 저장소(.git 폴더)를 생성
    $ cd [저장소_폴더명]      # 해당 폴더로 이동
    ```

### 3\. VS Code 및 리눅스 기초 명령

Git Bash 환경은 리눅스 명령어를 사용하므로, 파일 및 폴더 관리를 위한 기초 리눅스 명령을 알아야 합니다.

| 명령 (Command) | 설명 | 활용 예시 |
| :--- | :--- | :--- |
| `pwd` (print working directory) | 현재 작업 중인 디렉토리(폴더)의 경로를 출력합니다. | |
| `ls -al` (list) | 현재 폴더의 파일/폴더 목록을 숨김 파일(`-a`) 포함하여 자세한 정보와(`-l`) 함께 출력합니다. | |
| `cat [파일]` (concatenate) | 파일의 내용을 화면에 출력합니다. | |
| `echo "문자열"` | 문자열을 화면에 출력합니다. 파일 생성 및 수정에 주로 사용됩니다. | |
| `touch [파일]` | 비어있는 새 파일을 생성합니다. | |
| **`>` (리다이렉션)** | 화면의 출력 결과를 파일로 저장하며, **기존 내용을 지우고** 덮어씁니다. | `$ echo "1st line" > file.txt` |
| **`>>` (리다이렉션)** | 화면의 출력 결과를 파일로 저장하며, **기존 내용 뒤에 덧붙여서** 저장합니다. | `$ echo "2nd line" >> file.txt` |

-----

##  Week 4
커밋, 로그 이력, 과거 버전 이동

### 1\. 버전 이력 저장 (Add & Commit)

Git에서 버전 이력을 기록하려면 반드시 **`add` 명령 후 `commit` 명령**을 순서대로 실행해야 합니다.

| 명령 (Command) | 기능 |
| :--- | :--- |
| **`$ git status`** | 현재 파일들이 3가지 영역(작업 디렉토리, 스테이징 영역, 깃 저장소) 중 어디에 있는지, 파일의 상태(수정됨, 추적되지 않음 등)를 표시합니다. (`-s` 옵션으로 간결하게 볼 수 있습니다). |
| **`$ git add [파일/폴더]`** | 작업 디렉토리에서 수정한 파일이나 새로 생성된 파일(`untracked` or `modified`)을 **스테이징 영역**으로 이동시켜 커밋할 준비를 합니다. |
| **`$ git commit -m '메시지'`** | 스테이징 영역에 준비된 파일들을 **깃 저장소**에 최종 저장하며, 하나의 \*\*버전(커밋)\*\*으로 기록합니다. 이때 커밋 메시지(`-m '메시지'`)를 반드시 입력해야 합니다. |
| **`$ git commit -am '메시지'`** | `add`와 `commit`을 한 번에 실행합니다. 다만, **이미 Git이 추적하는 파일**을 수정한 경우에만 사용 가능합니다. |

### 2\. 버전 이력 확인 (Log & Show)

커밋된 버전 이력을 확인하는 명령입니다.

| 명령 (Command) | 기능 |
| :--- | :--- |
| **`$ git log`** | 저장된 모든 커밋 이력을 시간 순으로 상세하게 표시합니다. |
| **`$ git log --oneline`** | 커밋 이력을 각 커밋당 **한 줄**로 간결하게 표시합니다. 짧은 커밋 ID와 메시지를 볼 수 있습니다. |
| **`$ git log --graph`** | 커밋 이력을 **그래프** 형태로 표시하여 브랜치 및 병합 이력을 시각적으로 보여줍니다 커밋과 로그 이력, 과거 여행.pdf]. |
| **`$ git show`** | 가장 최근의 커밋(`HEAD`)에 대한 상세 정보와 함께 이전 버전과의 파일 \*\*변경 차이(Diff)\*\*를 표시합니다. |

> 💡 **커밋 ID (Commit ID)**: 모든 커밋을 구분하기 위한 고유한 번호입니다. SHA-1 해시 함수를 사용하여 생성된 40자리의 16진수 체크섬(checksum)입니다.

### 3\. 과거 버전으로의 이동 (Time Travel)

Git은 **HEAD**라는 포인터를 사용하여 현재 작업 중인(최신) 커밋을 가리킵니다. 이 **HEAD**를 이동하여 과거 버전으로 돌아갈 수 있습니다.

| 표현 (Expression) | 의미 |
| :--- | :--- |
| **`HEAD`** | 현재 작업하고 있는 **최신 커밋**을 가리킵니다. |
| **`HEAD~`** | 바로 **직전 커밋**을 가리킵니다 (HEAD의 1단계 이전). |
| **`HEAD~2` 또는 `HEAD~~`** | 현재로부터 **2단계 이전 커밋**을 가리킵니다. |

  * **과거 버전으로 이동**:

    ```bash
    $ git checkout HEAD~  # 바로 이전 커밋으로 HEAD를 이동 (과거 버전으로 이동)
    # 또는
    $ git checkout [커밋ID] # 특정 커밋 ID의 버전으로 이동
    ```

     `git checkout`은 브랜치 전환에도 사용되므로, 최근에는 \*\*`git switch -d [커밋ID]`\*\*를 사용하여 과거 버전으로 이동하는 것이 권장됩니다 커밋과 로그 이력, 과거 여행.pdf].

  * **최신 버전(브랜치)으로 복귀**:
    과거 버전으로 이동한 후 다시 최신 작업 내용이 있는 상태로 돌아가려면 **브랜치 이름**을 사용하여 복귀합니다.

    ```bash
    $ git checkout main  # 최신 버전(main 브랜치)으로 HEAD를 이동하여 복귀
    ```
##  Week 6 
파일 비교, 삭제, 복원 명령어 

### 1\. 파일 비교 (`git diff`)

`git diff` 명령은 Git의 3가지 영역 간의 파일 변경 내용을 보여주는 데 사용됩니다.

| 비교 대상 | 명령 (Command) | 설명 |
| :--- | :--- | :--- |
| **작업 디렉토리 ↔ 스테이징 영역** | **`$ git diff`** | 파일을 수정한 후 **`git add`를 하지 않은** 변경 내용, 즉 다음 커밋에 포함되지 않을 내용. |
| **스테이징 영역 ↔ 깃 저장소 (HEAD)** | **`$ git diff --staged`** (또는 `--cached`) | `git add`는 했지만 **`git commit`을 하지 않은** 변경 내용. |
| **깃 저장소 (HEAD) ↔ 작업 디렉토리** | **`$ git diff HEAD`** | 최신 커밋 이후 발생한 **모든** 변경 내용(add 여부 관계없이). |
| **특정 커밋 ↔ 다른 커밋** | **`$ git diff [커밋ID1] [커밋ID2]`** | 두 특정 버전(커밋) 간의 파일 변경 내용을 비교. |

### 2\. 파일 삭제 (`rm`, `git rm`)

파일을 삭제하는 방법은 Git의 추적(버전 관리) 여부에 따라 다릅니다.

| 명령 (Command) | 기능 | 설명 |
| :--- | :--- | :--- |
| **`$ rm [파일]`** (리눅스) | **작업 디렉토리**에서만 삭제 | Git 입장에서는 파일이 '수정됨(deleted)' 상태로 인식되며, `git add` 후 `commit` 해야 최종 삭제 이력이 남습니다. |
| **`$ git rm [파일]`** (Git) | **작업 디렉토리**와 **스테이징 영역**에서 삭제 | 파일을 삭제하고 동시에 다음 커밋에 반영할 준비(`staged`)를 합니다. |
| **`$ git rm --cached [파일]`** | **스테이징 영역**에서만 삭제 | 파일은 작업 디렉토리에 남겨두고, Git의 버전 관리 대상에서는 제외합니다 (`untracked` 상태). |

### 3\. 파일 복원 (`git restore`)

삭제되거나 변경된 파일을 이전 상태로 되돌립니다. **`git restore`** 명령은 작업 디렉토리 또는 스테이징 영역의 상태를 복구할 때 사용합니다.

| 명령 (Command) | 복원 대상 | 복원 기준 |
| :--- | :--- | :--- |
| **`$ git restore [파일]`** | **작업 디렉토리** | **스테이징 영역**에 있는 내용. |
| **`$ git restore --staged [파일]`** | **스테이징 영역** | \*\*깃 저장소(HEAD)\*\*의 내용. |
| **`$ git restore --source=HEAD --staged --worktree [파일]`** | **작업 디렉토리**와 **스테이징 영역** 모두 | \*\*깃 저장소(HEAD)\*\*의 내용 (가장 최신 커밋 상태로 완전히 복구) 파일 diff rm restore.pdf]. |

-----

##  Week 7
버전 태그 및 브랜치 관리 

### 1\. 버전과 태그 활용 (`git tag`)

  * **버전 (Version)**: 프로그램의 수정 및 개선 정도를 구분하기 위해 부여하는 식별자입니다. 일반적으로 **Semantic Versioning (SemVer)** 방식(예: `Major.Minor.Patch`)을 따릅니다.
  * **태그 (Tag)**: Git에서 특정 커밋(**버전**)에 의미있는 이름을 부여하여 중요한 릴리즈 지점(예: v1.0.0)을 표시할 때 사용합니다.

| 명령 (Command) | 종류 | 설명 |
| :--- | :--- | :--- |
| **`$ git tag v1.0`** | 일반 태그 | 특정 커밋에 간단한 별칭 부여. |
| **`$ git tag -a v1.0 -m '메시지'`** | **주석 태그** (권장) | 태그를 만든 사람, 이메일, 생성일, 주석 메시지 등의 상세 정보를 포함. |
| **`$ git tag`** | 태그 목록 보기 | 현재 저장소에 있는 모든 태그 목록을 출력. |
| **`$ git show [태그이름]`** | 태그 상세 보기 | 특정 태그에 대한 상세 정보(특히 주석 태그의 메시지)를 출력. |
| **`$ git tag -d [태그이름]`** | 태그 삭제 | 지정된 태그를 삭제. |

### 2\. 브랜치 개요와 관리 (`git branch`, `git switch`)

  * **브랜치 (Branch) 개념**: 파일 집합을 통째로 복사하여 독립적으로 개발을 진행하는 개념입니다. 하나의 프로젝트에서 메인 코드에 영향을 주지 않고 새로운 기능 개발, 버그 수정 등을 동시에 진행할 수 있습니다.

| 명령 (Command) | 기능 | 설명 |
| :--- | :--- | :--- |
| **`$ git branch`** | 브랜치 목록 확인 | 지역 저장소의 브랜치 목록을 확인하고, 현재 작업 중인 브랜치(`HEAD`)를 `*`로 표시. |
| **`$ git branch [이름]`** | 브랜치 생성 | 현재 커밋 상태를 기준으로 새로운 브랜치를 생성. |
| **`$ git switch [이름]`** | 브랜치 이동 (전환) | **HEAD** 포인터를 지정된 브랜치로 이동 (최신 권장 명령). |
| **`$ git switch -c [이름]`** | 생성 및 이동 | 브랜치를 **생성**과 동시에 해당 브랜치로 **이동**. |
| **`$ git branch -d [이름]`** | 브랜치 삭제 | **병합된** 브랜치를 안전하게 삭제. |
| **`$ git branch -D [이름]`** | 브랜치 강제 삭제 | **병합되지 않은** 내용이 있어도 강제로 삭제 (주의 필요). |

-----

## Week 8  
원격 저장소 연동 

### 1\. 원격 저장소 복제 (`git clone`)

  * **원격 저장소**: GitHub처럼 네트워크상의 서버에 위치하며, 여러 개발자가 공유하는 저장소입니다.
  * **Clone (복제)**: 원격 저장소의 전체 내용을 내 PC의 **지역 저장소**로 통째로 복사해 가져오는 명령입니다 지역과 원격 저장소 브랜치 연동.pdf]. 공개된 저장소는 소유와 관계없이 누구나 복제 가능합니다.
    ```bash
    $ git clone [원격_저장소_URL]
    ```
      * 복제 시, Git은 자동으로 원격 저장소에 \*\*`origin`\*\*이라는 기본 별칭(별명)을 부여합니다.

### 2\. 지역과 원격 저장소 동기화 (Push, Pull, Fetch)

지역 저장소에서 작업한 내용을 원격에 반영하거나, 원격의 최신 변경 사항을 지역으로 가져올 때 사용되는 핵심 명령어입니다.

| 명령어 | 방향 | 기능 | 설명 |
| :--- | :--- | :--- | :--- |
| **`$ git push`** | 지역 → 원격 (업로드) | 지역 저장소의 커밋을 원격 저장소(`origin`)로 올려 **공개**합니다 지역과 원격 저장소 브랜치 연동.pdf]. |
| **`$ git pull`** | 원격 → 지역 (가져오기 + 병합) | 원격의 최신 내용을 가져와(`fetch`) **자동으로** 현재 지역 브랜치에 \*\*병합(`merge`)\*\*까지 수행합니다. |
| **`$ git fetch`** | 원격 → 지역 (가져오기만) | 원격의 최신 내용을 가져와 지역에 저장하지만, **병합은 하지 않습니다**. 가져온 내용을 확인한 후 수동으로 `git merge`를 수행할 때 사용합니다. |

### 3\. 개인 접근 토큰 (Personal Access Token, PAT)

  * **필요성**: GitHub는 2021년 8월 13일 이후부터 보안상의 이유로 기존의 **비밀번호 인증을 더 이상 지원하지 않습니다**.
  * **역할**: 대신 \*\*개인 접근 토큰(PAT)\*\*을 생성하여 Push/Pull 등의 원격 저장소 접근 시 인증 수단으로 사용해야 합니다.
  * **인증 방법**: `git push` 실행 시 브라우저를 통한 인증 화면이 나타나거나, 생성한 PAT를 직접 입력하여 인증을 수행합니다 지역과 원격 저장소 브랜치 연동.pdf].

## Week 10

OSS 라이선스 및 Stash, Untracked 파일 정리

### 1\. OSS의 정의 및 의미

  * OSS (Open Source Software): 누구나 소스 코드를 자유롭게 보고, 사용, 수정, 배포할 수 있는 소프트웨어입니다.
  * 핵심은 단순한 무료가 아니라 **자유(Freedom) 보장**에 있습니다.
  * OSI (Open Source Initiative): 공개 소스 정의(OSD)를 관리하고 인증 마크를 부여합니다.
  * 자유 소프트웨어 vs 오픈소스:
      * 자유 소프트웨어: 사용자의 자유, 철학을 강조합니다.
      * 오픈소스: 실용성, 기술적 활용을 강조합니다.

-----

### 2\. OSS 주요 라이선스

| 라이선스 | Copyleft 강도 | 소스 공개 의무 | 특징 |
| :--- | :--- | :--- | :--- |
| GPL | 강함 | O | 파생물도 반드시 GPL을 유지해야 합니다. |
| LGPL | 중간 | 동적 링크 시 애플리케이션 공개 X | |
| Apache 2.0 | 약함 (Permissive) | X | 특허 사용을 허용합니다. |
| MIT | 매우 약함 (Permissive) | X | 저작권 명시만 하면 자유롭습니다. |

-----

### 3\. Stash (임시 저장)

  * 커밋하지 않은 변경 사항을 스택에 임시로 저장합니다.
  * 주로 브랜치 전환 시 작업 내용을 임시 보관하는 데 사용됩니다.

### 4\. Untracked 파일 삭제

버전 관리 대상이 아닌(untracked) 파일을 삭제합니다.

| 명령 (Command) | 기능 |
| :--- | :--- |
| `git clean -n` | 삭제될 목록을 확인합니다 (Dry run). |
| `git clean -f` | 실제 삭제를 수행합니다. |
| `git clean -i` | 대화형으로 선택하여 삭제할 수 있습니다. |

-----

## Week 11

브랜치 병합 (Merge)

### 1\. Fast-forward Merge

  * 브랜치 이력이 일직선상에 있을 때 발생합니다.
  * 별도의 병합 커밋(Merge Commit) 없이 포인터만 최신 커밋으로 이동합니다.

### 2\. 3-way Merge

  * 개발 이력이 갈라져 공통 조상(Common Ancestor)이 있는 상황에서 발생합니다.
  * 공통 조상을 기준으로 변경 사항을 통합하여 **새로운 병합 커밋**을 생성합니다.
  * 명령 예시:
    ```bash
    git merge --no-ff [branch] # 강제로 병합 커밋을 생성합니다.
    ```

### 3\. Squash Merge

  * 특정 브랜치(또는 여러 커밋)의 모든 변경 이력을 하나의 커밋으로 압축하여 병합합니다.
  * 명령 예시:
    ```bash
    git merge --squash [branch] # 변경 내용을 병합 커밋으로 만들기 위해 스테이징합니다.
    git commit # 압축된 하나의 커밋으로 저장합니다.
    ```

### 4\. 병합 충돌 (Merge Conflict)

  * 두 브랜치에서 동일한 파일의 동일한 라인을 다르게 수정한 경우에 발생합니다.
  * Git은 자동으로 병합할 수 없어 개발자에게 충돌 해결을 요청합니다.
  * 충돌 발생 시 메시지: `CONFLICT (content)`

### 5\. 충돌 해결

  * 충돌 파일에 삽입된 충돌 마커(`<<<<<<<`, `=======`, `>>>>>>>`)를 제거하고 원하는 내용으로 수정합니다.
  * 수정된 파일을 스테이징 영역에 추가(`git add`)하고, 커밋(`git commit`)하여 병합을 완료합니다.
  * 충돌 해결 취소 시:
    ```bash
    git merge --abort # 병합 시도를 취소하고 병합 전 상태로 되돌립니다.
    ```

-----

## Week 12

커밋 재배치 (Rebase) 및 히스토리 수정

### 1\. Rebase 개요

  * 브랜치의 커밋 기준점을 다른 커밋 위로 이동시켜 히스토리를 재구성합니다.
  * 결과적으로 커밋 히스토리를 **직선(Linear)** 형태로 깔끔하게 유지할 수 있습니다.

### 2\. 주의사항

  * **이미 원격 저장소에 공유된(Push된) 커밋에는 절대 Rebase를 사용하지 않아야 합니다.** 히스토리가 변경되어 다른 팀원과 충돌을 일으킬 수 있습니다.

### 3\. 최신 커밋 수정 (`commit --amend`)

가장 최근의 커밋(HEAD)을 수정합니다. 커밋 메시지나 내용을 변경할 수 있습니다.

```bash
git add [file] # 수정된 파일이 있다면 스테이징
git commit --amend # 최신 커밋을 덮어씁니다.
```

### 4\. 과거 커밋 수정 (Interactive Rebase)

`HEAD`로부터 $\text{N}$단계 이전 커밋까지 대화형으로 수정합니다.

```bash
git rebase -i HEAD~N
```

| 명령 (Action) | 기능 |
| :--- | :--- |
| `pick` | 커밋을 그대로 유지합니다. |
| `reword` | 커밋 메시지를 수정합니다. |
| `squash` | 이전 커밋과 통합하여 하나의 커밋으로 만듭니다. |
| `drop` | 해당 커밋을 히스토리에서 삭제합니다. |

### 5\. VS Code 기능 활용

  * Source Control 메뉴: Git 상태 및 기본 명령을 GUI로 수행합니다.
  * Git Graph 확장: 커밋 히스토리 및 브랜치 상태를 시각적인 그래프로 보여줍니다.
  * Diff 비교: 파일 간 변경 내용을 쉽게 비교할 수 있습니다.
  * Restore로 변경 취소: `git restore` 명령을 GUI로 실행하여 작업 내용을 되돌릴 수 있습니다.

-----

## Week 13

버전 되돌리기 (Reset & Revert)

### 1\. Reset 개요

  * 브랜치 포인터를 이동시켜 이전 커밋으로 돌아가며, 이 과정에서 **이력 삭제 위험**이 있습니다.
  * 저장소(`.git` 폴더) / 인덱스(Staging Area) / 작업 디렉토리(Working Directory) 각각에 다르게 영향을 줍니다.
  * 실수로 `reset --hard`를 실행한 경우 복구:
    ```bash
    git reset --hard ORIG_HEAD # reset 하기 직전 상태로 복구
    ```

| 옵션 (Mode) | 브랜치 포인터 이동 | Index 영향 | Working Directory 영향 |
| :--- | :--- | :--- | :--- |
| `--soft` | O | X | X |
| `--mixed` (기본) | O | O (변경 내용만 남김) | X |
| `--hard` | O | O | O (변경 내용까지 모두 삭제) |

### 2\. Revert 개요

  * 이미 원격 저장소에 공유된 커밋을 되돌릴 때 **안전하게** 사용합니다.
  * 되돌리고자 하는 커밋의 변경 사항을 취소하는 **새로운 취소 커밋**을 히스토리에 추가합니다. 기존 이력은 그대로 남습니다.
  * 명령 예시:
    ```bash
    git revert [commitID] # 특정 커밋의 변경을 되돌리는 새로운 커밋을 생성합니다.
    git revert --no-edit # 커밋 메시지 수정 없이 바로 생성합니다.
    git revert --continue # 충돌 해결 후 되돌리기를 계속합니다.
    git revert --abort # 되돌리기 작업을 취소합니다.
    ```




